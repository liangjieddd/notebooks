[TOC]

# Haar特征

## 1.简介

​		看是看harr特征的时候我就想到了harr小波变换，但是我就是不明白这两个东西有什么联系。 

​		小波变换是为了解决**傅里叶变换的空间分辨率无法细化**而产生的一种新的函数分解方式。

​		一个函数与不同的基函数的**卷积**运算就能得到**该基函数的系数**，当基函数在函数上滑动时，当基函数的形状与函数的某个部分**相近**时就能获得最大的结果。这时该基函数就能获得**最大的系数**。

​		**如果一个基函数拥有较大的系数那么就说明该基函数与函数有很长的相关性（形状很像）**。

> 所以harr特征的特征算子都是模仿的各种各样的**图像特征**。 

​		Haar-like特征是计算机视觉领域一种常用的**特征描述算子**(也称为Haar特征，这是因为Haar-like是受到一维haar小波的启示而发明的,所以称为类Haar特征)，后来又将Haar-like扩展到三维空间(称为3DHaar-Like)用来描述视频中的动态特征。关于Haar的发展历程如图1所示。

![img](https://img-blog.csdn.net/20170106143949414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUwNzAyMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 1.1 Haar特征/矩形特征

​		Haar特征本身并不复杂，就是用图中黑色矩形所有像素值的和减去白色矩形所有像素值的和。

![img](https://img-my.csdn.net/uploads/201211/23/1353646276_1594.png)

## 2.Haar-like特征的特点

 		目前最常用的还是Haar-like特征，描述图像的特征，多用于人脸检测、行人检测等目标检测；

​		Haar-like特征可以理解为卷积模板(如同prewitt、sobel算子，当然不完全一样)，Haar-like特征模板内只有白色和黑色两种矩形，并定义该模板的特征值为白色矩形像素和减去黑色矩形像素和。

​		**Haar特征值反映了图像的灰度变化情况。**例如：脸部的一些特征能由矩形特征简单的描述，如：眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。但矩形特征只对一些简单的图形结构，如**边缘、线段较敏感**，所以只能描述特定走向（水平、垂直、对角）的结构。

## 3.Haar-like特征分类

Haar-like特征可以分为四类：

* 线性特征
* 边缘特征
* 点特征（中心特征）
* 对角线特征；

也可以分成三类：

* 边缘特征
* 线性特征(包含对角线特征)
* 点特征（中心特征）：如图1(D)所示。

## 4.Haar-like特征的计算

​			通过改变**特征模板的大小和位置**，可在图像子窗口中穷举出大量的特征。

* 图1(D)中的的特征模板称为“特征原型”
* 特征原型在图像子窗口中扩展（平移伸缩）得到的特征称为“矩形特征”
* 矩形特征的值称为“特征值”。

​		矩形特征可位于图像任意位置，大小也可以任意改变，所以矩形特征值是**矩形模版类别、矩形位置和矩形大小**这三个因素的函数。

​		故类别、大小和位置的变化，使得很小的检测窗口含有非常多的矩形特征，如：在24*24像素大小的检测窗口内矩形特征数量可以达到16万个。

1) Haar特征个数计算参考博客：
http://blog.csdn.net/xiaowei_cqu/article/details/8216109

2)利用积分图Haar特征的加速算法
        刚开始认为积分图(Integral image)是个高深的东西，其实很简单。**对于一个灰度图像I而言，其积分图也是一张与I尺寸相同的图**，只不过该图上任意一点(x,y)的值是指从灰度图像I的左上角与当前点所围成的矩形区域内**所有像素点灰度值之和**，有点耳熟吧。类似于图像直方图与图像累积直方图的关系，这里只不过是二维的图像。

![img](https://img-blog.csdn.net/20170106144447093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUwNzAyMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

​		当把扫描图像一遍，到达图像右下角像素时，积分图像就构造好了。积分图构造好之后，图像中任何矩阵区域的像素累加和都可以通过简单运算得到如图2所示。

​		而Haar-like特征值无非就是**两个矩阵像素和的差**，同样可以在常数时间内完成。所以矩形特征的特征值计算，只与此特征矩形的端点的积分图有关，所以不管此特征矩形的尺度变换如何，特征值的计算所消耗的时间都是常量。这样只要遍历图像一次，就可以求得所有子窗口的特征值。

### 4.1 Haar特征个数的计算

Rainer Lienhart计算Haar特征个数的公式：

![img](https://img-my.csdn.net/uploads/201211/23/1353646336_9902.png)


其中，![img](https://img-my.csdn.net/uploads/201211/23/1353646436_5972.png)为图片大小，![img](https://img-my.csdn.net/uploads/201211/23/1353646449_1838.png)为矩形特征大小，![img](https://img-my.csdn.net/uploads/201211/23/1353646455_6574.png)表示矩形特征在水平和垂直方向的能放大的最大比例系数。

对于45°的rotated特征（如1(c)和1(d)），w，h表示如下图所示：

![img](https://img-my.csdn.net/uploads/201211/23/1353647051_9429.png)

其计算公式为：

![img](https://img-my.csdn.net/uploads/201211/23/1353646944_2705.png)

*论文中没有说明，个人认为此处除了Z，XY值也有变化：

![img](https://img-my.csdn.net/uploads/201211/23/1353648245_1409.png)

下面是我理解的计算过程:
首先有两点要清楚：
1、对于某特定大小的特征，在窗口内滑动计算。
      也就是如图1（a）特征大小为2\*1，对于24\*24的图像。水平可滑动23步，垂直滑动24步，所以共有23\*24个特征。

2、对于一个特征，特征本身沿水平、竖直方向分别缩放。

​      还看特征1（a），特征大小为2\*1，则延水平方向可放大为：4\*1，6\*1，8\*1，…，24\*1；竖直方向可放大为：2\*1，2\*2，2\*3，…，2\*24。即每个特征有XY种放大方式。（！放大的矩形特征并限制保持2:1的比例！）

计算特征个数：

~~~
int getHaarCount(int W,int H,int w,int h){
	int X=W/w;
	int Y=H/h;
	int count=0;
 
	//放大Haar特征到 iw*jh
	for (int i=1;i<=X;i++)
		for(int j=1;j<=Y;j++)
			//滑动iw*jh矩形，遍历图像计算每个位置Haar特征
			for(int x=1;x<=W-i*w+1;x++)
				for(int y=1;y<=H-j*h+1;y++)
					count++;
 
	return count;
}

~~~

​		对于45°特征，由于Rainer Lienhart定义的w，h与原矩阵含义不同（参见第一幅图），即实际滑动的矩阵框为(h+w)*(w+h)。
所以只要用如下方式调用原函数：

~~~
getHaarCount(W,H,h+w,w+h);
~~~

当然如果你喜欢写代码，也可以写个新的函数：

~~~
int getRotatedHaarCount(int W,int H,int w,int h){
	int X=W/(w+h);//计算新的X
	int Y=H/(w+h);//计算新的Y
	int count=0;
	for (int i=1;i<=X;i++)
		for(int j=1;j<=Y;j++)
			//注意这里滑动窗口边界变化
			for(int x=1;x<=W-i*(w+h)+1;x++)
				for(int y=1;y<=H-j*(w+h)+1;y++)
					count++;
 
	return count;
}
~~~

计算在24*24的图片中，几种特征的个数为：

![img](https://img-my.csdn.net/uploads/201211/23/1353647342_1046.png)

可以看到和论文用公式计算得到的值是一致的

![img](https://img-my.csdn.net/uploads/201211/23/1353647405_9999.png)

---------------------
另一种递推计算方法：

​		特征个数虽然很大，但很有规律，不用程序用笔也很容易推出递推公式。

如1(a)和1(b)特征递推为：(12^2)*(1+2+...+24)=43,200